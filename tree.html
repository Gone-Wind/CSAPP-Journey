<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ„ æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info {
            position: absolute; top: 10px; left: 10px; color: #fff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            z-index: 10; padding: 10px; background: rgba(0, 0, 0, 0.6); border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: opacity 0.3s;
        }
        #info:hover { opacity: 0.8; }
        #upload-container {
            position: absolute; bottom: 10px; right: 10px; z-index: 10;
        }
        .file-input {
            padding: 10px 15px; border: none; background-color: #A52A2A; color: white;
            cursor: pointer; border-radius: 5px; font-weight: bold;
            transition: background-color 0.3s;
        }
        .file-input:hover { background-color: #C0392B; }
        .input_video { display: none; } /* éšè— MediaPipe è§†é¢‘æµ */
    </style>
</head>
<body>
    <div id="info">
        <h3>ğŸŒŸ åœ£è¯æ ‘æ‰‹åŠ¿æ§åˆ¶</h3>
        å½“å‰çŠ¶æ€: <span id="current-state" style="color: #FFD700;">åˆæ‹¢æ€ (CONE)</span><br>
        <p style="font-size: 0.9em; margin-top: 5px;">
        **æ‰‹åŠ¿æŒ‡ä»¤:**
        <ul>
            <li>**æ¡æ‹³ (Closed Fist):** â†’ **åˆæ‹¢æ€** (åœ£è¯æ ‘å½¢çŠ¶)</li>
            <li>**äº”æŒ‡æ‰“å¼€ (Open Palm):** â†’ **æ•£å¼€æ€** (ç…§ç‰‡/è£…é¥°ç‰©æ¼‚æµ®)</li>
            <li>**æŠ“å– (Pinch/Grab):** â†’ **ç…§ç‰‡æ”¾å¤§æ€** (æ•£å¼€æ€ä¸‹é€‰ä¸­æœ€è¿‘ç…§ç‰‡)</li>
            <li>**æ‰‹ç§»åŠ¨/æ—‹è½¬:** â†’ æ—‹è½¬åœºæ™¯/è°ƒæ•´ç›¸æœº</li>
        </ul>
        </p>
    </div>
    <div id="upload-container">
        <label for="photo-upload" class="file-input">â¬†ï¸ ä¸Šä¼ åœ£è¯ç…§ç‰‡ (JPG/PNG)</label>
        <input type="file" id="photo-upload" accept="image/*" multiple style="display: none;">
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675466854/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>

    <script>
        // --- 1. å…¨å±€å˜é‡å’Œåˆå§‹åŒ– ---

        const NUM_INSTANCES = 6000; // è£…é¥°ç‰©æ•°é‡
        const PHOTO_COUNT_MAX = 20; // æœ€å¤§ç…§ç‰‡æ•°é‡
        const photoMeshes = []; // å­˜å‚¨ç…§ç‰‡ Mesh
        let currentPhotoFocus = null; // å½“å‰æ”¾å¤§çš„ç…§ç‰‡

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // ä¸»è‰²ç³»ï¼šå“‘å…‰ç»¿ã€é‡‘å±é‡‘ã€åœ£è¯çº¢
        const COLORS = {
            GREEN: 0x225522, // å“‘å…‰ç»¿
            GOLD: 0xFFD700,  // é‡‘å±é‡‘
            RED: 0xA52A2A,   // åœ£è¯çº¢
            PARTICLE: 0xCCCCCC // ç²’å­é¢œè‰²
        };

        // åå¤„ç† - å®ç°ç”µå½±æ„Ÿçš„è¾‰å…‰ (UnrealBloomPass)
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.8, // å¼ºåº¦ Strength (å¢å¼ºç”µå½±æ„Ÿ)
            0.5, // åŠå¾„ Radius
            0.95 // é˜ˆå€¼ Threshold (åªè®©æœ€äº®çš„ç‰©ä½“å‘å…‰)
        );
        composer.addPass(bloomPass);

        const instancedMeshes = [];
        const dummy = new THREE.Object3D();
        const originalPositions = []; // åˆå§‹åˆæ‹¢æ€ä½ç½®
        const scatteredPositions = []; // æ•£å¼€æ€ä½ç½®

        let currentState = 'CONE'; // CONE, CLOUD, FOCUS
        const stateDisplay = document.getElementById('current-state');

        // å…‰ç…§
        scene.add(new THREE.AmbientLight(0x404040, 3));
        const pointLight = new THREE.PointLight(COLORS.GOLD, 10, 100);
        pointLight.position.set(0, 15, 0);
        scene.add(pointLight);

        // çª—å£è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });


        // --- 2. åœ£è¯æ ‘å‡ ä½•ä½“ç”Ÿæˆ (InstancedMesh) ---

        function createDecorations() {
            // å‡ ä½•ä½“ï¼šçƒã€æ­£æ–¹ä½“ã€ç³–æœæ£
            const sphereGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const boxGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const candyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 3, 8);

            const geometries = [sphereGeometry, boxGeometry, candyGeometry];
            const materials = [
                new THREE.MeshStandardMaterial({ color: COLORS.GOLD, metalness: 1.0, roughness: 0.05 }), // é‡‘å±é‡‘ï¼Œé«˜å…‰
                new THREE.MeshStandardMaterial({ color: COLORS.RED, metalness: 0.8, roughness: 0.2 }), // åœ£è¯çº¢
                new THREE.MeshStandardMaterial({ color: COLORS.GREEN, metalness: 0.5, roughness: 0.5 })
            ];

            for (let i = 0; i < 3; i++) {
                const mesh = new THREE.InstancedMesh(geometries[i], materials[i], NUM_INSTANCES / 3);
                instancedMeshes.push(mesh);
                scene.add(mesh);
            }

            // è®¾ç½®åˆå§‹ä½ç½® (åˆæ‹¢æ€ï¼šåœ†é”¥ä½“) å’Œç›®æ ‡ä½ç½® (æ•£å¼€æ€ï¼šéšæœºäº‘)
            for (let i = 0; i < NUM_INSTANCES; i++) {
                // åˆæ‹¢æ€ (åœ†é”¥ä½“å½¢çŠ¶)
                const h = (i / NUM_INSTANCES) * 30; // é«˜åº¦ 0 åˆ° 30
                const r = (30 - h) * 0.3; // é”¥ä½“åŠå¾„
                const angle = Math.random() * Math.PI * 2;
                const x = r * Math.cos(angle);
                const z = r * Math.sin(angle);
                const y = h - 15; // å±…ä¸­

                originalPositions.push(new THREE.Vector3(x, y, z));

                // æ•£å¼€æ€ (éšæœºäº‘)
                scatteredPositions.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                ));
            }

            // åˆå§‹åŒ– InstancedMesh ä½ç½®åˆ°åˆæ‹¢æ€
            let instanceIndex = 0;
            instancedMeshes.forEach(mesh => {
                for (let i = 0; i < mesh.count; i++) {
                    dummy.position.copy(originalPositions[instanceIndex]);
                    dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    dummy.scale.setScalar(0.5 + Math.random() * 0.5);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    instanceIndex++;
                }
                mesh.instanceMatrix.needsUpdate = true;
            });
        }


        // --- 3. ç…§ç‰‡äº‘å¤„ç† ---

        const textureLoader = new THREE.TextureLoader();
        const photoUpload = document.getElementById('photo-upload');

        photoUpload.addEventListener('change', (event) => {
            const files = event.target.files;
            Array.from(files).forEach((file, index) => {
                if (photoMeshes.length >= PHOTO_COUNT_MAX) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const texture = textureLoader.load(e.target.result);
                    createPhotoMesh(texture);
                };
                reader.readAsDataURL(file);
            });
        });

        function createPhotoMesh(texture) {
            // ä½¿ç”¨ PlaneGeometry åˆ›å»ºç…§ç‰‡ç½‘æ ¼
            const geometry = new THREE.PlaneGeometry(8, 8); // ç…§ç‰‡å°ºå¯¸
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9,
                depthWrite: false // é¿å…æ·±åº¦å†²çª
            });
            const mesh = new THREE.Mesh(geometry, material);

            // è®¾ç½®ç…§ç‰‡åœ¨åˆæ‹¢æ€å’Œæ•£å¼€æ€çš„ä½ç½®
            const targetScatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * 80,
                (Math.random() - 0.5) * 80,
                (Math.random() - 0.5) * 80
            );

            // å°†ç…§ç‰‡åˆå§‹è®¾ç½®åˆ°åˆæ‹¢æ€ä½ç½®é™„è¿‘çš„éšæœºç‚¹ (åœ¨æ ‘çš„åœ†é”¥ä½“é™„è¿‘)
            const initialConePos = originalPositions[Math.floor(Math.random() * NUM_INSTANCES)].clone().add(new THREE.Vector3(
                Math.random() - 0.5,
                Math.random() - 0.5,
                Math.random() - 0.5
            ));

            mesh.userData = {
                initialPosition: initialConePos,
                scatteredPosition: targetScatterPos,
                isFocused: false
            };

            mesh.position.copy(initialConePos);
            mesh.lookAt(camera.position);
            photoMeshes.push(mesh);
            scene.add(mesh);

            // å°†ç…§ç‰‡æ•£å¼€ä½ç½®åŠ å…¥åˆ°æ€»æ•£å¼€ä½ç½®åˆ—è¡¨
            scatteredPositions.push(targetScatterPos);
        }

        // --- 4. çŠ¶æ€åˆ‡æ¢ä¸è¿‡æ¸¡åŠ¨ç”» (TWEEN) ---

        function updateStateDisplay(newState) {
             const map = {
                'CONE': 'åˆæ‹¢æ€ (CONE)',
                'CLOUD': 'æ•£å¼€æ€ (CLOUD)',
                'FOCUS': 'ç…§ç‰‡æ”¾å¤§æ€ (FOCUS)'
            };
            stateDisplay.textContent = map[newState] || newState;
            stateDisplay.style.color = newState === 'FOCUS' ? '#A52A2A' : (newState === 'CLOUD' ? '#9FEF00' : '#FFD700');
        }

        function transitionState(newState) {
            if (currentState === newState) return;
            
            currentState = newState;
            updateStateDisplay(newState);

            TWEEN.removeAll(); 

            let instanceIndex = 0;
            // è£…é¥°ç‰©è¿‡æ¸¡
            instancedMeshes.forEach(mesh => {
                for (let i = 0; i < mesh.count; i++) {
                    const targetPos = newState === 'CONE' ? originalPositions[instanceIndex] : scatteredPositions[instanceIndex];
                    const currentMatrix = new THREE.Matrix4();
                    mesh.getMatrixAt(i, currentMatrix);
                    const currentPos = new THREE.Vector3().setFromMatrixPosition(currentMatrix);

                    new TWEEN.Tween(currentPos)
                        .to(targetPos, 1800)
                        .easing(TWEEN.Easing.Quadratic.InOut)
                        .onUpdate(() => {
                            dummy.position.copy(currentPos);
                            // ä¿æŒæ—‹è½¬å’Œç¼©æ”¾
                            dummy.rotation.setFromRotationMatrix(currentMatrix);
                            dummy.scale.setFromMatrixScale(currentMatrix);
                            dummy.updateMatrix();
                            mesh.setMatrixAt(i, dummy.matrix);
                            mesh.instanceMatrix.needsUpdate = true;
                        })
                        .start();

                    instanceIndex++;
                }
            });

            // ç…§ç‰‡è¿‡æ¸¡
            photoMeshes.forEach((mesh, photoIndex) => {
                const scatterIndex = NUM_INSTANCES + photoIndex;
                const targetPos = newState === 'CONE' ? mesh.userData.initialPosition : scatteredPositions[scatterIndex];

                if (newState !== 'FOCUS' || mesh !== currentPhotoFocus) {
                    new TWEEN.Tween(mesh.position)
                        .to(targetPos, 1800)
                        .easing(TWEEN.Easing.Quadratic.InOut)
                        .start();
                    new TWEEN.Tween(mesh.rotation)
                        .to({ x: 0, y: 0, z: 0 }, 1800) // é€€å‡ºFOCUSæ—¶é‡ç½®æ—‹è½¬
                        .easing(TWEEN.Easing.Quadratic.InOut)
                        .start();
                }
            });

            // ç›¸æœºå’Œç„¦ç‚¹é€»è¾‘
            if (newState !== 'FOCUS') {
                currentPhotoFocus = null;
                // æ¢å¤é»˜è®¤ç›¸æœºä½ç½®
                new TWEEN.Tween(camera.position).to({ x: 0, y: 0, z: 50 }, 1800).easing(TWEEN.Easing.Quadratic.InOut).start();
                new TWEEN.Tween(scene.rotation).to({ x: 0, y: 0, z: 0 }, 1800).easing(TWEEN.Easing.Quadratic.InOut).start();
            }
        }

        function focusOnPhoto(mesh) {
            if (currentState === 'FOCUS' && currentPhotoFocus === mesh) return;
            if (currentState === 'CONE') return; // åˆæ‹¢æ€ä¸èƒ½æ”¾å¤§ç…§ç‰‡

            currentPhotoFocus = mesh;
            transitionState('FOCUS');

            // ç›®æ ‡ç›¸æœºä½ç½®ï¼šç…§ç‰‡å‰æ–¹12ä¸ªå•ä½
            const targetCameraPos = mesh.position.clone().add(new THREE.Vector3(0, 0, 12));
            
            // ç›¸æœºå¹³æ»‘ç§»åŠ¨
            new TWEEN.Tween(camera.position)
                .to(targetCameraPos, 1500)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .start();

            // ç…§ç‰‡è‡ªèº«æ—‹è½¬åŠ¨ç”»ï¼Œä½¿å…¶é¢å‘ç›¸æœº
            new TWEEN.Tween(mesh.rotation)
                .to({ x: 0, y: 0, z: 0 }, 1500)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .start();
        }

        // --- 5. MediaPipe Hands æ•´åˆ ---

        const videoElement = document.createElement('video');
        videoElement.classList.add('input_video');
        document.body.appendChild(videoElement);

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675466854/${file}`
        });
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const cameraMP = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });
        cameraMP.start();

        let lastHandPose = 'Unknown';
        let rotationDeltaX = 0;
        let rotationDeltaY = 0;
        let lastHandX = null;
        let lastHandY = null;

        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                lastHandPose = 'Unknown';
                lastHandX = null;
                lastHandY = null;
                return;
            }

            const landmarks = results.multiHandLandmarks[0];
            const fingerTips = [
                landmarks[4], landmarks[8], landmarks[12], landmarks[16], landmarks[20]
            ];
            const palmBase = landmarks[0];

            // --- æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ---
            const tipDistanceThreshold = 0.15; // æŒ‡å°–åˆ°æŒæ ¹çš„è·ç¦»é˜ˆå€¼ (æ¡æ‹³)
            const openDistanceThreshold = 0.25; // å¼ å¼€çš„è·ç¦»é˜ˆå€¼ (å¼ å¼€)
            const pinchThreshold = 0.05; // æåˆé˜ˆå€¼

            const isClosedFist = fingerTips.every(tip => {
                return Math.hypot(tip.x - palmBase.x, tip.y - palmBase.y) < tipDistanceThreshold;
            });

            const isOpenPalm = fingerTips.every(tip => {
                return Math.hypot(tip.x - palmBase.x, tip.y - palmBase.y) > openDistanceThreshold;
            });

            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];
            const isPinching = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y) < pinchThreshold;

            let currentPose = 'Unknown';
            if (isClosedFist) {
                currentPose = 'Closed_Fist';
            } else if (isOpenPalm) {
                currentPose = 'Open_Palm';
            } else if (isPinching) {
                currentPose = 'Pinch_Grab';
            }

            // --- çŠ¶æ€åˆ‡æ¢é€»è¾‘ (åªåœ¨æ‰‹åŠ¿å˜åŒ–æ—¶è§¦å‘ï¼Œé¿å…è¿‡åº¦åˆ‡æ¢) ---
            if (currentPose !== lastHandPose && currentPose !== 'Unknown') {
                if (currentPose === 'Closed_Fist') {
                    transitionState('CONE');
                } else if (currentPose === 'Open_Palm') {
                    transitionState('CLOUD');
                } else if (currentPose === 'Pinch_Grab' && currentState === 'CLOUD' && photoMeshes.length > 0) {
                    // æŠ“å–é€»è¾‘ï¼šåœ¨æ•£å¼€æ€ä¸‹ï¼Œé€‰æ‹©æœ€è¿‘çš„ç…§ç‰‡è¿›è¡Œæ”¾å¤§
                    const normalizedX = palmBase.x * 2 - 1; // è½¬æ¢ä¸º -1 åˆ° 1
                    const normalizedY = - (palmBase.y * 2 - 1); // è½¬æ¢ä¸º -1 åˆ° 1

                    const raycaster = new THREE.Raycaster();
                    const pointer = new THREE.Vector2(normalizedX, normalizedY);
                    raycaster.setFromCamera(pointer, camera);

                    const intersects = raycaster.intersectObjects(photoMeshes);
                    if (intersects.length > 0) {
                        focusOnPhoto(intersects[0].object);
                    }
                }
            }

            // --- æ—‹è½¬æ§åˆ¶é€»è¾‘ (æ‰‹æ—‹è½¬) ---
            if (currentState === 'CLOUD' || currentState === 'FOCUS') {
                const handX = palmBase.x; // 0.0 to 1.0
                const handY = palmBase.y; // 0.0 to 1.0

                if (lastHandX !== null && lastHandY !== null) {
                    // è®¡ç®—æ‰‹éƒ¨ç§»åŠ¨ä½œä¸ºæ—‹è½¬å¢é‡ (æ˜ å°„åˆ°åœºæ™¯æ—‹è½¬)
                    // ç§»åŠ¨å› å­ 0.05 è°ƒæ•´æ—‹è½¬é€Ÿåº¦
                    rotationDeltaY += (handX - lastHandX) * 0.05; // æ°´å¹³ç§»åŠ¨å½±å“ Y è½´æ—‹è½¬
                    rotationDeltaX += (handY - lastHandY) * 0.05; // å‚ç›´ç§»åŠ¨å½±å“ X è½´æ—‹è½¬
                }
                lastHandX = handX;
                lastHandY = handY;
            } else {
                lastHandX = null;
                lastHandY = null;
            }

            lastHandPose = currentPose;
        }

        // --- 6. åŠ¨ç”»å¾ªç¯ ---
        function animate(time) {
            requestAnimationFrame(animate);

            TWEEN.update(time);

            // åœºæ™¯æ—‹è½¬ (æ‰‹åŠ¿æ§åˆ¶)
            if (currentState === 'CLOUD' || currentState === 'FOCUS') {
                // åº”ç”¨æ—‹è½¬å¢é‡
                scene.rotation.y += rotationDeltaY;
                scene.rotation.x += rotationDeltaX;
                // ç¼“æ…¢å‡é€Ÿï¼Œå®ç°æƒ¯æ€§æ•ˆæœ
                rotationDeltaY *= 0.85;
                rotationDeltaX *= 0.85;
            } else {
                // åˆæ‹¢æ€ä¸‹çš„é»˜è®¤ç¼“æ…¢æ—‹è½¬
                scene.rotation.y += 0.001;
            }
            
            // å¦‚æœå¤„äºç…§ç‰‡æ”¾å¤§æ€ï¼Œç¡®ä¿ç›¸æœºä¸€ç›´é¢å‘ç…§ç‰‡
            if (currentState === 'FOCUS' && currentPhotoFocus) {
                camera.lookAt(currentPhotoFocus.position);
            }
            
            // ç…§ç‰‡åœ¨æ•£å¼€æ€ä¸‹è‡ªè½¬
            if (currentState === 'CLOUD') {
                photoMeshes.forEach(mesh => {
                    mesh.rotation.y += 0.005;
                    mesh.rotation.x += 0.002;
                });
            }


            // ä½¿ç”¨ Composer æ¸²æŸ“å¸¦æœ‰è¾‰å…‰æ•ˆæœçš„åœºæ™¯
            composer.render();
        }

        // å¯åŠ¨åº”ç”¨
        createDecorations();
        animate();
    </script>
</body>
</html>